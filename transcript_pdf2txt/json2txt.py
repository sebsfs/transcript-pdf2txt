import os
from utils import write_txt
from .correct_orientation import correct_if_rotated

def generate_txt(json_f, output_file, y_threshold = 5, lim = 50):
        """
        The function `generate_txt` takes a JSON-formatted text extraction (json_f) 
        and reconstructs it into a properly ordered plain text file. 
        It arranges words based on their spatial coordinates, ensuring both horizontal 
        and vertical alignment by applying positional rules. 

        Parameters:
        - json_f: The input text in JSON format, typically generated by PyMuPDF or PaddleOCR.  
        - output_file: Path where the resulting .txt file will be written.  
        - y_threshold (default = 5): Vertical tolerance used to decide if words belong to the same line/row.  
        - lim (default = 50): Limit used to extract an intermediate portion of a detected text box, 
        preventing overly long bounding box captures from being written directly.  

        In short, this function converts structured JSON text into a human-readable text file, 
        preserving the logical reading order through coordinate-based alignment.
        """
        json_format = correct_if_rotated(json_f)
        output_lines = []

        num_pages = len(json_format)

        for page_index in range(num_pages):
            transcript_data = json_format[page_index]['results']

            # Find the longest word and use it as a reference
            longest_word = None
            max_len = 0
            reference_char_width = None

            for item in transcript_data:
                text = item['text'].strip()
                if len(text) > max_len and len(text) < lim:
                    bbox = item['bbox']
                    ancho = bbox['x_max'] - bbox['x_min']
                    alto = bbox['y_max'] - bbox['y_min']

                    # Ignorar palabras verticales
                    if alto > ancho:
                        continue

                    longest_word = text
                    max_len = len(text)
                    reference_char_width = ancho / (max_len + 4)

            if reference_char_width is None:
                continue  # If there are no words on this page, skip

            # Extract useful information
            elements = []
            x_min_global = float('inf')
            for item in transcript_data:
                bbox = item['bbox']
                x_min = bbox['x_min']
                y_center = (bbox['y_min'] + bbox['y_max']) / 2
                x_min_global = min(x_min_global, x_min)
                elements.append({
                    'text': item['text'],
                    'x_min': x_min,
                    'y_center': y_center
                })

            # Group words by line
            lines = []
            for el in sorted(elements, key=lambda e: e['y_center']):
                added = False
                for line in lines:
                    if abs(line['avg_y'] - el['y_center']) < y_threshold:
                        line['words'].append(el)
                        line['avg_y'] = sum(w['y_center'] for w in line['words']) / len(line['words'])
                        added = True
                        break
                if not added:
                    lines.append({'avg_y': el['y_center'], 'words': [el]})

            # Construct lines with word respecting coordinates
            for line in lines:
                words = sorted(line['words'], key=lambda w: w['x_min'])
                buffer_size = 2000
                row = [' '] * buffer_size

                for word in words:
                    palabra = f"{word['text']}"
                    x_pos = int((word['x_min'] - x_min_global) / reference_char_width)
                    x_pos = max(0, x_pos)
                    for i, char in enumerate(palabra):
                        if x_pos + i < buffer_size:
                            row[x_pos + i] = char

                output_lines.append("".join(row).rstrip())
            output_lines.append("\n\n")
    
        # write TXT file
        write_txt(output_file, output_lines)

        if os.path.getsize(output_file) == 0:
            os.remove(output_file)